###! DATE: 08 September, 2011
###!********************************************
###!***      Copyright 2011 NAOMI MARUYAMA   ***
###!***      ALL RIGHTS RESERVED             ***
###!********************************************
###! LICENSE AGREEMENT Ionosphere Plasmasphere Electrodynamics (IPE) model
###! DEVELOPER: Dr. Naomi Maruyama
###! CONTACT INFORMATION:
###! E-MAIL : Naomi.Maruyama@noaa.gov
###! PHONE  : 303-497-4857
###! ADDRESS: 325 Broadway, Boulder, CO 80305
###!--------------------------------------------  
# Make settings and options for compiler lf95(linux64 L8.00) on naomilx.swpc.noaa.gov
FORTRAN_COMPILER=$(COMPILER) 
# Locations:
HOME_dev=$(CURDIR)

# Compiler:
### command and flags ###
# uncomment when debugging
# -pg: profile
DEBUG1=###-traceback -check all -ftrapuv #####-fpe0
DEBUG =###-g -pg  $(DEBUG1)
DEBUG=-g -O0 -ftz -traceback -check bounds -fpe0
DEBUG=
OPT_FLAG=-O3 -fp-model precise
#OPT_FLAG=
PARALLEL_FLAG=####-openmp
MEM_FLAG=###########-heap-arrays 10

# common (*.o)
###LD	= $(FORTRAN_COMPILER)
LDFLAGS	= ${OPT_FLAG} $(DEBUG) ${PARALLEL_FLAG} ${MEM_FLAG}  
LDLIBS	= -lm   #######-L$(NETCDF_DIR)/lib -lnetcdf

# flip: Fortran77 (*.f .FOR .for)
FC	= $(FORTRAN_COMPILER)
FFLAGS	=${OPT_FLAG} $(DEBUG) ${PARALLEL_FLAG} ${MEM_FLAG}  

# eldyn: Fortran77 (*.f .FOR .for)
FFLAGS_e=${OPT_FLAG} $(DEBUG) ${PARALLEL_FLAG} ${MEM_FLAG} 

# Fortran90 (*.f90)
FFLAGS90=${OPT_FLAG} $(DEBUG) ${PARALLEL_FLAG} ${MEM_FLAG} 

# etc
SHELL	= /bin/sh
RM	= rm -f
PROF	= gprof
#

MOD_PATH=-
INCLUDE_PATH=-I

# Set flag to either use the GPTL timing library, or dummy stubs
USE_GPTL = yes
ifeq ($(USE_GPTL),yes)
# Set include path for GPTL
  GPTL_CPPFLAGS = -I/scratch1/portfolios/BMC/fim/GPTL/gptl-4.3.1/include
# For auto-profiling of MPI functions, set USE_PMPI=yes. The name of the GPTL
# library in this case is libgptl_pmpi.a. Otherwise the name is libgptl.a
  USE_PMPI = no
  ifeq ($(USE_PMPI),yes)
    GPTL_LDFLAGS = -L/scratch1/portfolios/BMC/fim/GPTL/gptl-4.3.1/lib -lgptl_pmpi
# When auto-profiling the MPI layer, set HAVE_IARGCGETARG=yes if the Fortran
# compiler supports functions iargc and getarg.
    HAVE_IARGCGETARG = no
  else
    ifeq ($(PAR),sms)
      GPTL_LDFLAGS = -L/scratch1/portfolios/BMC/fim/GPTL/gptl-4.3.2/intel_mpi/lib -lgptl
    else
      GPTL_LDFLAGS = -L/scratch1/portfolios/BMC/fim/GPTL/gptl-4.3.2/intel_nompi/lib -lgptl
    endif
  endif
# AUTOINST=yes enables function-level compiler-generated auto-profiling,
  AUTOINST = no
  ifeq ($(AUTOINST),yes)
    GPTL_FFLAGS = -finstrument-functions -g -O2
    GPTL_LDFLAGS += -finstrument-functions
  endif
# If GPTL was built with PAPI support, add the required flags
  HAVE_PAPI = no
  ifeq ($(HAVE_PAPI),yes)
    GPTL_LDFLAGS += -L/path/to/papi/lib -lpapi -lpfm
  endif
else
  GPTL_LDFLAGS = -L../../dummygptl -lgptl
endif

# SMS library location
ifeq ($(USE_GPTL),yes)
# If available, use SMS version compiled with auto-profiling flag
  SMS = /home/Jacques.Middlecoff/SMS/SMS_r395_intel_mpt/
else
  SMS = /home/Jacques.Middlecoff/SMS/SMS_r395_intel_mpt/
endif

# SMS
SMSFLAGS = -I $(SMS)/include
PINCLUDES = $(INCLUDES:.inc=.inc.SMS )
PPP = $(SMS)/bin/ppp
#HaloSize=10 is a guess
# --Fmodule=module_decomp tells SMS to insert "use module_decomp" in every file it processes.
# This is needed to 1) not require the user to add it everywhere; 2) it is not needed in serial code;
# 3) module decomp contains all the decomp info that SMS needs in the routines it processes.
PPP_FLAGS  = --Fmodule=module_decomp --Free --comment --HaloSize=10
PPP_FLAGS1 =                         --Free --comment --HaloSize=10
PPP_HEADER_FLAGS = --header --comment
CPP       = /lib/cpp
DEFINES   =
CPP_FLAGS = -traditional -P $(GPTL_CPPFLAGS) $(DEFINES)
SMS_LDFLAGS = -L$(SMS)/lib -lsms
FCserial = ifort
FCparallel = mpif90
